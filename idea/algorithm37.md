## 37. Sudoku Solver

**题目 :**

Write a program to solve a Sudoku puzzle by filling the empty cells.

Empty cells are indicated by the character `'.'`.

You may assume that there will be only one unique solution.

```
|5 3 .|. 7 .|. . .|      |5 3 4|6 7 8|9 1 2|
|6 . .|1 9 5|. . .|      |6 7 2|1 9 5|3 4 8|
|. 9 8|. . .|. 6 .|      |1 9 8|3 4 2|5 6 7|
-----------------        -------------------
|8 . .|. 6 .|. . 3|      |8 5 9|7 6 1|4 2 3|
|4 . .|8 . 3|. . 1|  --> |4 2 6|8 5 3|7 9 1|
|7 . .|. 2 .|. . 6|      |7 1 3|9 2 4|8 5 6|
-----------------        -------------------
|. 6 .|. . .|2 8 .|      |9 6 1|5 3 7|2 8 4|
|. . .|4 1 9|. . 5|      |2 8 7|4 1 9|6 3 5|
|. . .|. 8 .|. 7 9|      |3 4 5|2 8 6|1 7 9|
```

**题意 :**

解决一个数独。

没填数字的地方用英文句号表示。

假设问题只有一种解。

**思路 :**

看了一个最直接的方法，就是为每个空格尝试所有的9种填法。如果有m个空格，那么最坏的情况下要尝试9^m次。

具体来说，递归的方法。如果当前空格填入的字符合法，就递归填好后的棋盘。如果递归返回false，说明当前空格处填当前字符不可行，则继续尝试下一个字符。

关于合不合法的判断，一行一列都简单，关键是一个小方格内怎么判断：

```
for(int i=0; i<9; ++i)
{
	if(board[(row/3)*3 + i/3][board[(col/3)*3 + i%3]] == c)
	{
		return false;
	}
}
```

通过`(row/3)*3`和`(col/3)*3`将方格内的任意位置归到左上角。行通过`+i/3`实现每3个数加一行，列通过`+i%3`实现每3个数回到列首。